---
phase: 01-foundation-refactoring
plan: 02
type: execute
---

<objective>
Deduplicate SAM prediction logic in click_collector.py and add .env.example documentation.

Purpose: Reduce maintenance burden by extracting duplicated SAM prediction code to a helper method, and improve onboarding by documenting environment variables.
Output: Refactored click_collector.py with `_predict_mask()` helper, new `.env.example` file.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONCERNS.md
@.planning/codebase/CONVENTIONS.md

**Codebase constraints:**
- Use `[OK]`, `[ERROR]`, `[WARNING]` prefixes for status messages
- Use `except Exception:` not bare `except:`
- Private functions prefixed with underscore: `_predict_mask()`
- Google-style docstrings for functions

**Relevant source files:**
@cryoem_annotation/annotation/click_collector.py (SAM prediction at lines ~150-154 and ~352-358)
@cryoem_annotation/config.py (shows environment variables used)

**Prior decisions affecting this phase:**
- None

**Deferred issues being addressed:**
- None

**From 01-01-PLAN.md:**
- matplotlib_utils.py now exists
- click_collector.py imports plt from matplotlib_utils
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract SAM prediction helper in click_collector.py</name>
  <files>cryoem_annotation/annotation/click_collector.py</files>
  <action>
In RealTimeClickCollector class, create a private method `_predict_mask()`:

```python
def _predict_mask(self, x: int, y: int) -> tuple:
    """
    Run SAM prediction for a single point.

    Args:
        x: X coordinate of click
        y: Y coordinate of click

    Returns:
        Tuple of (best_mask, best_score) where best_mask is the highest-scoring
        mask from SAM's multi-mask output.
    """
    point_coords = np.array([[x, y]])
    point_labels = np.array([1])  # Foreground point

    masks, scores, logits = self.predictor.predict(
        point_coords=point_coords,
        point_labels=point_labels,
        multimask_output=True,  # Get 3 masks
    )

    # Select best mask (highest score)
    best_mask_idx = np.argmax(scores)
    best_mask = masks[best_mask_idx]
    best_score = scores[best_mask_idx]

    return best_mask, best_score
```

Then replace both instances of the duplicate prediction logic:

1. In the main click handler (~line 150): Replace the inline SAM prediction with:
   `best_mask, best_score = self._predict_mask(x, y)`

2. In the fallback/console mode (~line 352): Replace the inline SAM prediction with:
   `best_mask, best_score = self._predict_mask(x, y)`

Ensure the return values are unpacked correctly in both call sites.
Keep the surrounding code (segmentation data dict creation, etc.) in place.
  </action>
  <verify>
python -c "from cryoem_annotation.annotation.click_collector import RealTimeClickCollector; print('OK')"
grep -n "_predict_mask" cryoem_annotation/annotation/click_collector.py | head -5
  </verify>
  <done>
- `_predict_mask()` method exists in RealTimeClickCollector
- Only ONE definition of SAM prediction logic (in the helper)
- Both call sites use `self._predict_mask(x, y)`
- Module imports successfully
  </done>
</task>

<task type="auto">
  <name>Task 2: Create .env.example with documented environment variables</name>
  <files>.env.example</files>
  <action>
Create `.env.example` in the project root documenting environment variables from config.py.

Read config.py to identify all environment variables used (look for os.environ or os.getenv calls).

Based on CLAUDE.md and config.py, include at minimum:
- Any config-related env vars
- SAM checkpoint path if configurable via env
- Any GPU/CUDA related settings

Format with comments explaining each variable:

```
# CryoEM Annotation Tool Environment Variables
# Copy this file to .env and customize as needed

# Path to SAM model checkpoint (optional - can also use --checkpoint CLI arg)
# SAM_CHECKPOINT=/path/to/sam_vit_h_4b8939.pth

# Configuration file path (optional)
# CRYOEM_CONFIG=/path/to/config.yaml

# CUDA device selection (optional, defaults to cuda:0 if available)
# CUDA_VISIBLE_DEVICES=0
```

Add any other environment variables found in the codebase.
Include sensible example values where appropriate.
  </action>
  <verify>
test -f .env.example && echo ".env.example exists" || echo "MISSING"
cat .env.example | head -20
  </verify>
  <done>
- .env.example file exists in project root
- All environment variables from config.py are documented
- Each variable has a comment explaining its purpose
- Example values provided where helpful
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from cryoem_annotation.annotation.click_collector import RealTimeClickCollector"` succeeds
- [ ] grep shows `_predict_mask` defined once and called twice in click_collector.py
- [ ] `.env.example` exists with documented variables
- [ ] `pytest tests/ -v --tb=short` passes (if tests exist)
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- SAM prediction logic exists in exactly one place
- .env.example documents all environment variables
- No errors or warnings introduced
- Phase 1 complete
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-refactoring/01-02-SUMMARY.md`:

# Phase 1 Plan 2: Code Cleanup Summary

**[Substantive one-liner]**

## Accomplishments
- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified
- `path/to/file` - Description

## Decisions Made
[Key decisions and rationale, or "None"]

## Issues Encountered
[Problems and resolutions, or "None"]

## Next Step
Phase 1 complete, ready for Phase 2: Multi-Grid Data Model
</output>
